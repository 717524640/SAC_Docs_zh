\section{SAC命令初探}
\subsection{SAC命令长什么样？}
一个完整的SAC命令一般由``命令+选项+参数''构成，其中命令必须有，选项和参数可以成对
出现，也可以只出现其中一个。命令、选项以及参数之间用空格分开。如果要将多个命令写在
一行，要用分号隔开每个命令。例如：
\begin{SACCode}
SAC> funcgen seismogram delta 0.1 npts 1000
SAC> write seis.SAC
\end{SACCode}
其中，\lstinline{funcgen}和\lstinline{write}是命令；\lstinline{seismogram}是选项，
但是没有参数；\lstinline{0.1}是选项\lstinline{delta}的参数、\lstinline{1000}是选项
\lstinline{npts}的参数；而\lstinline{seis.SAC}则是一个无选项的参数\footnote{也可以
有一堆选项。}。

这里简单解释一下选项（option）和参数（argument）的区别。选项是由命令规定的，
其控制了命令的一些特性，选项是不可以随便修改的。而参数是任意的，SAC只指定了其类型
（比如是数字还是字符串），或者对其可取的值做限制，用户需要根据自己的需求修改参数。

\subsection{大小写}
SAC的命令和选项都是不区分大小写的，这意味着你可以根据自己的喜好使用\lstinline{funcgen}
或者\lstinline{FUNCGEN}，SAC在解释命令前都会将其转换为大写字母。

需要注意的是，由于Linux本身是区分大小写的，所以对于出现在参数中的文件名、目录名
或者由引号包围的字符串来说，大小写是完全不同的。比如\lstinline{seis.SAC}和
\lstinline{SEIS.SAC}是两个完全不同的参数。

\subsection{命令简写}
SAC的大多数命令以及选项都有简写形式。比如上面的两条命令简写形式如下：
\begin{SACCode}
SAC> fg seis d 0.1 n 1000
SAC> w seis.SAC
\end{SACCode}

命令和选项究竟可以简写成怎样的形式，是由SAC自身规定的。简写的好处在于，在不产生歧义
的前提下尽量减少用户的击键数；坏处在于，若对命令不是足够熟悉，简写后的命令变得很
难读和难理解。比如你一看就知道\lstinline{delta}代表的是数据采样间隔，而
\lstinline{d}却不那么直观，可能是\lstinline{delta}，也可能是\lstinline{demon}。
所以，简写很好用，但是应该仅用在那些常使用的命令上，不要滥用。

本文档中，在介绍命令语法时，仅给出命令和选项的完整形式
\footnote{官方英文文档中是通过大小写的方式隐晦地给出简写形式的；
《数字地震波形分析》一书中，是通过下滑线给出简写形式；二者都不够直观和友好。
最关键的是，给出简写形式大大增加了写文档的工作量。}，
在命令下的例子中视情况给出其简写形式。对于未给出简写形式的命令，就需要用户自己去
猜或者尝试了。

\subsection{查看命令语法}
SAC自带了英文的帮助文档，详细解释了每个命令的语法，可以通过\lstinline{help}命令
查看相应文档:
\begin{SACCode}
SAC> help funcgen write   // 命令的简写是h fg w
\end{SACCode}
也可以直接查看\lstinline{$SACHOME/aux/help}下的文档，或者查看本手册的命令部分。

\subsection{参数默认值}
为了让SAC易学易用，几乎所有的命令参数都有一个``系统默认值''，这些``系统默认值''
都是经过精心挑选的，
同时用户又可以随时修改参数值。这样的设计使得SAC易用同时又不失灵活性。

下面以C语言为例做一些说明\footnote{有些地方不是很准确。}，希望能够帮助理解SAC的参数
默认值的一些特点。

在C语言中，函数有主函数和子函数之分，变量又有全局变量和局部变量之分。所有的变量
都可以被初始化为适当的值。

任意一个子函数，都可以使用全局变量的值，即函数的执行可以被全局变量所控制；
同时也可以修改全局变量的值，这使得代码的管理和调试变得困难。一种实际的做法
是定义专门的子函数来修改全局变量。

任意一个子函数，又都有自己的局部变量。这些局部变量在每次子函数被调用时都会被定义、初始化、
使用和赋值，一旦子函数调用结束，变量即被撤销。如果给这些变量加上\lstinline{static}
修饰符，则这些局部变量变身为静态局部变量。

静态局部变量，会在程序刚开始的时候就完成初始化，也是唯一的一次初始化。静态局部变量
仅在定义它的子函数里可见，子函数可以任意修改静态局部变量的值，
但是每次子函数调用结束时变量不会被撤销，因此再次调用一个子函数时，静态局部变量的值
可能已经被上一次的子函数调用所修改。

SAC中有与之相对应的一些概念。sac就是一个主函数，每一个命令都是一个子函数。所以SAC
命令可以分为2类：
\begin{description}
\item[操作执行类] 对数据进行某些操作（受全局变量控制，同时又有自己的静态局部变量）；
\item[参数设定类] 改变SAC的内部参数值（即C语言中专门用于修改全局变量的子函数）； 
\end{description}

在启动SAC（主函数）的时候，所有的选项（C语言中的全局变量和静态局部变量）都会被初始化为
指定的``缺省参数值''（全局变量和静态局部变量的唯一一次初始化）。

使用参数设定类命令的时候，其修改了SAC的全局参数，可能会影响接下来执行的所有其它
命令的执行效果。使用操作执行类命令的时候，在命令中设定参数，相当于修改静态局部变量的值，不仅会
影响当前命令的执行，也会影响之后所有同名命令的执行。

即：

当你在某个命令中为某个选项指定了一个参数值的时候，该参数值会
成为该命令的该选项的``参数当前值''，该``参数当前值''即成为接下来所有
该命令的该选项的``当前默认值''。

鉴于SAC的这样一个特性，在一次会话中，多次执行同一个命令时，一定需要注意选项的当前值
是多少，因为这可能会影响到后面的一系列结果，这个必须牢记！

当你在一次会话中执行了很多个命令的时候，SAC参数可能已经被弄得一片混乱，
你可以使用\nameref{cmd:inicm}命令在不退出SAC的情况下重新初始化。

下面用例子解释一下：
\begin{SACCode}
SAC> funcgen
SAC> plot
SAC> funcgen step delta 0.1 npts 1000
SAC> plot
SAC> funcgen boxcar
SAC> plot
\end{SACCode}

\begin{enumerate}
\item 命令\lstinline{funcgen}的系统默认值为\lstinline{funcgen impulse npts 100 delta 1.0 begin 0.}。
\item 第一个\lstinline{funcgen}命令没有使用任何选项和参数，其直接使用系统默认值，
    生成一个脉冲数据，并保存到内存中。该数据的起始时间为0，采样间隔为\lstinline{1.0}，
    数据点数为\lstinline{100}。
\item \lstinline{plot}命令会打开一个绘图窗口，并将内存中的数据绘制在窗口中；
\item 第二个\lstinline{funcgen}命令生成了一个step函数\footnote{注意：内存中的脉冲函数已经没了。}
    ，并设置其采样间隔为\lstinline{0.1}，数据点数为\lstinline{1000}。
\item \lstinline{0.1}和\lstinline{1000}分别成为\lstinline{delta}和\lstinline{npts}的``参数当前值''。
\item 第三个\lstinline{funcgen}命令生成了boxcar函数，从绘图结果可以看出\lstinline{delta}的值为
    \lstinline{0.1}，\lstinline{npts}的值为\lstinline{1000}。即继承了上一次命令的参数值。
\end{enumerate}

对于本文档，除非上下文有明确说明，否则
大部分例子都运行在单独的会话中，即每个例子都省略了启动sac和退出sac的命令。
另外，除非特别情况，均省略\nameref{cmd:plot}命令，用户应该学会随时
\nameref{cmd:plot}以查看当前内存中的波形结果。
